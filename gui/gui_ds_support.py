#
#Created by Luis Madrid
#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 6.2
#  in conjunction with Tcl version 8.6
#    May 31, 2021 08:48:12 PM CDT  platform: Darwin

import sys
import pandas as pd
import numpy as np
import tkinter.filedialog
import tkinter as ttk3
import tkinter.ttk as ttk2
import gui_ds
import os
import time

dirname = os.path.dirname(__file__)
dirname1 = dirname[:-4]+ '\\backend'
sys.path.append(dirname1)
import Backend_ds_v_0_0_1

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def set_Tk_var():
    global combobox
    combobox = tk.StringVar()

def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    add_to_cb()

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import gui_ds
    gui_ds.vp_start_gui()


#--------------------------------------------------------------------------
#FUNCTION TO LOCATE FILES AND PLACE THEM ON A LIST

def btn_openfile():
    global finalDataFrame

    btn_rest()
    filetypes = (
        ('CSV files', '*.csv'),('Excel files', '*.xlsx'),
        ('All files', '*.*')
    )
    w.filenames = ttk3.filedialog.askopenfilenames(
        title = 'Open files',
        initialdir = '/',
        filetypes = filetypes
    )

    nText = ''
    for each in w.filenames:
        nText = each.split('/')[-1] + '\n'
        w.textDisplay.insert(ttk3.END, nText)

    w.textDisplay.config(state="disabled")

    #CREATE DataFrame, AND AUTOMATICALLY FILL COLUMN NAME DROP DOWN
    all_files = w.filenames
    listFiles = []
    #LOOP THRU FILE NAMES AND ADD THEM INTO A LIST
    file_type = all_files[0][-4:]

    if file_type == '.csv':
        for filename in all_files:
            df_all_temp = pd.read_csv(filename, index_col = None, header = 0)
            listFiles.append(df_all_temp)
    elif file_type == 'xlsx':
        for filename in all_files:
            df_all_temp = pd.read_excel(filename, index_col = None, header = 0)
            listFiles.append(df_all_temp)

    #PENDING: NEED TO MODIFY THE FIX NAME FOR ELEMENT ID
    df_all_final = pd.concat(listFiles, axis = 0, ignore_index = True)

    new_df = shrink_data(df_all_final)

    #read automatically column header
    w.TCombobox2["values"] = list(df_all_final.columns.values)
    w.TCombobox2.configure(state = 'readonly')
    w.TCombobox3["values"] = list(df_all_final.columns.values)
    w.TCombobox3.configure(state = 'readonly')

    #GLOBAL VARIABLES
    finalDataFrame = new_df

    #WINDOW UPDATE BASED ON ACTIONS
    window_update(new_df)

    return
#--------------------------------------------------------------------------
#FUNCTION FOR BUTTON "CLEAR" SELECTED FILES
def btn_rest():
    w.textDisplay.config(state="normal")
    w.filenames = []
    w.textDisplay.delete("1.0", "end")
    w.textDisplay.insert("1.0", "")
    return

#--------------------------------------------------------------------------
#DROP DOWN LIST
def add_to_cb():
    w.TCombobox1['values']= ('Maximum', 'Minimum')
    w.TCombobox1.configure(state = 'readonly')
    return

#--------------------------------------------------------------------------
#READ INPUT TO BOX
def run_btn():
    #record time
    start_time = time.time()
    #open scroll text for recording
    w.Scrolledtext2.config(state="normal")

    #Input from users
    text_data = w.Scrolledtext1.get("1.0", ttk3.END)
    val_combb = w.TCombobox1.get()
    val_column = w.TCombobox2.get()
    elm_column = w.TCombobox3.get()

    #get list of elements and files from inputs
    elm_list1 = Backend_ds_v_0_0_1.elm_input(text_data)
    ls_arch = w.filenames

    #PROGRESS BAR INFO
    p_update = w.TProgressbar1

    m_list = Backend_ds_v_0_0_1.gen_dataframe(elm_list1, val_combb, finalDataFrame, val_column, p_update, elm_column)

    #end record time
    end_time = time.time()
    final_time = round(end_time - start_time, 2)

    #message box for user
    n_time = "Time run: " + str(final_time) + ' seconds' + '\n'
    miss_elm = "The following elements were not found: " + str(m_list) + '\n'
    w.Scrolledtext2.insert(ttk3.END, miss_elm)
    w.Scrolledtext2.insert(ttk3.END, n_time)

    #lock recording on scroll text
    w.Scrolledtext2.config(state="disabled")

    return

#--------------------------------------------------------------------------
#Shrink memory usage by modifying data type // NOT IMPLEMENTED DUE TO NOT EXACT NUMBERS

def shrink_data(dataframe1):
    col_num = dataframe1.shape[1]
    dummynum = 0
    exit_df = pd.DataFrame

    while dummynum < col_num:
        title_name = dataframe1.iloc[:0].columns[dummynum]
        dummynum += 1

        try:
            current_type = dataframe1[title_name].dtypes
            max_col_val = max(dataframe1[title_name])
            min_col_val = min(dataframe1[title_name])

            #MAXIMUM VALUES PER TYPE
            maxfloat16 = np.finfo(np.float16).max
            minfloat16 = np.finfo(np.float16).min
            maxfloat32 = np.finfo(np.float32).max
            minfloat32 = np.finfo(np.float32).min
            maxfloat64 = np.finfo(np.float64).max
            minfloat64 = np.finfo(np.float64).min

            maxint8 = np.iinfo(np.int8).max
            minint8 = np.iinfo(np.int8).min
            maxint16 = np.iinfo(np.int16).max
            minint16 = np.iinfo(np.int16).min
            maxint32 = np.iinfo(np.int32).max
            minint32 = np.iinfo(np.int32).min

            if current_type == "float64":
                if max_col_val < maxfloat32 and min_col_val > minfloat32:
                    dataframe1[title_name] = dataframe1[title_name].astype('float32')
                elif max_col_val < maxfloat64 and min_col_val > minfloat64:
                    dataframe1[title_name] = dataframe1[title_name].astype('float64')

            elif current_type == "int64":
                if max_col_val < maxint8 and min_col_val > minint8:
                    dataframe1[title_name] = dataframe1[title_name].astype('int8')
                elif max_col_val < maxint16 and min_col_val > minint16:
                    dataframe1[title_name] = dataframe1[title_name].astype('int16')
                elif max_col_val < maxint32 and min_col_val > minint32:
                    dataframe1[title_name] = dataframe1[title_name].astype('int32')

            elif current_type == "object":
                dataframe1[title_name] = dataframe1[title_name].astype('category')

        except:
            dataframe1[title_name] = dataframe1[title_name].astype('category')

    print(dataframe1.dtypes)
    print(dataframe1.memory_usage(deep = True))

    return dataframe1
#--------------------------------------------------------------------------
#Message window to keep user informed.
def window_update(df_final):
    w.Scrolledtext2.config(state="normal")
    nText = "Rows assessed: " + str(len(df_final)) + '\n'
    w.Scrolledtext2.insert(ttk3.END, nText)
    w.Scrolledtext2.config(state="disabled")
    return
